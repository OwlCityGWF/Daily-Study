/*
* js空间分为栈，堆，池(一般也会归类为栈中)
* 栈放变量,堆放复杂对象,池存放常量.
* 闭包中的变量存放在堆内存中
 */
/**
 * A弹出调用栈后,函数A中的变量这时候存储在堆上的，
 * 所以函数B依旧能引用到函数A中的变量.
 * 现在的JS引擎可以通过逃逸分析辨别出那些变量需要存储在堆上
 * 那些需要存储在栈上.
 * @returns {B}
 * @constructor
 */
function A() {
	let a = 1;
	function B() {
		console.log(a);
	}
	return B
}

/**
 * V8引擎中所有JS对象都是通过堆来进行
 * 内存分配:
 * 初始分配:当声明变量并赋值时,V8引擎就会在堆内存中分配给这个变量
 * 继续申请: 当已申请的内存不足以存储这个变量时,V8引擎就会继续申请内存,
 * 直到堆的大小达到v8引擎内存上限为止
 * V8引擎对堆内存中的JS对象进行
 * 分代管理:
 * 新生代: 存活周期较短的JS对象,如临时变量，字符串等
 * 老生代: 经过多次垃圾回收仍然存活,存活周期较长的对象
 * 垃圾回收算法:
 * 引用计数: 通过判断对象是否有指向它的引用，如果没有则释放内存，致命问题：循环引用
 * 标记清除: 将不再使用的对象定义为"无法到达的对象",即从根部(全局对象)出发定时扫描内存中的对象,
 * 凡是能从根部到达的对象,保留.那些从根部出发无法触及到的对象被标记为不再使用,稍后进行回收
 *
 */
