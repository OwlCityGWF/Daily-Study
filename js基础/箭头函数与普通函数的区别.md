### 关于箭头函数的参数
    1.如果箭头函数没有参数,直接写一个空括号即可
    2.如果箭头函数的参数只有一个,也可以省略包裹参数的括号
    3.如果箭头函数有多个参数,将参数依次用逗号分隔,包裹在括号中即可
### 关于箭头函数函数体
    1.如果箭头函数的函数体只有一句代码,就是简单返回某个变量或者返回一个简单的JS表达式,可以省去函数体的大括号
    2.如果箭头函数的函数体只有一句代码,就是返回一个对象,可以这样写:
```ecmascript 6
// 用小括号包裹要返回的对象
let getTempItem = id => ({id: id, name: "Temp" });
```
    3.如果箭头函数的函数体只有一条语句并且不需要返回值(最常见的是调用一个函数),可以给这条语句前面加一个void关键字
```ecmascript 6
let fn = () => void doesNotReturn();
```
箭头函数最常见的用处是简化回调函数
### 箭头函数与普通函数的区别
    1.语法更加简洁，清晰
    2.箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this.他会捕获自己在定义时所处的外层执行环境的this，并继承这个this值.所以,箭头函数中this的指向在它被定义的时候就已经确定了,之后永远不会改变.
```ecmascript 6
let id = 'Global';
function fun1() {
  setTimeout(function() {
    console.log(this.id);
  }, 2000);
}
function fun2() {
  setTimeout(() => {
  console.log(this.id)  
}, 2000)
}
fun1.call({id: 'Obj'}); // 'Global'
fun2.call({id: 'Obj'}); // 'Obj'
```
> 函数fun1中的setTimeout中使用普通函数,2s后函数执行,这时函数其实是在全局作用域执行的,所以this指向Window对象,this.id就指向全局变量id，所以输出'Global'.但是函数fun2中的setTimeout中使用的是箭头函数，这个箭头函数的this在定义时就确定了,它继承了它外层fun2的执行环境中的this而fun2调用时this被call
> 方法改变到了对象{id:'Obj''}中,所以输出'Obj'

### 箭头函数继承而来的this指向永远不变
对象obj的方法b是使用箭头函数定义的,这个函数中的this就永远指向它定义时所处的全局执行环境中的this即便这个函数是作为对象obj的方法调用,this依旧指向window对象
### call()/apply()/bind()无法改变箭头函数中this的指向
call()/apply()/bind()方法可以用来动态修改函数执行时this的指向,但由于箭头函数但this定义时就已经确定且永远不会改变,所以使用这些方法永远也改变不了箭头函数this的指向.
### 箭头函数不能作为构造函数使用
    new过程
    1.JS内部首先会生成一个对象
    2.再把函数中的this指向该对象
    3.然后执行构造函数中的语句
    4.最终返回该对象实例
    但是，因为箭头函数没有自己的this,它的this其实是继承了外层执行环境中的this,且this指向永远不会随在那里调用，被谁调用而改变,所以箭头函数不能作为构造函数使用,或者说构造函数不能定义成箭头函数,否则new调用时会报错
### 箭头函数没有自己的arguments
    箭头函数没有自己的arguments对象,在箭头函数中访问arguments实际上获得的是外层局部执行环境中的值
    可以在箭头函数中使用reset参数代替arguments对象,来访问箭头函数的参数列表
### 箭头函数没有原型prototype
### 箭头函数不能用作Generator函数,不能使用yeild关键字

























